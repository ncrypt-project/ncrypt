<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"secureexec.js.html":{"id":"secureexec.js.html","title":"Source: secureexec.js","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Source: secureexec.js /** * @namespace SecureExec * */ var SecureExec = {}; SecureExec.stack = require('./stack.js'); SecureExec.exception = require('./exception.js'); SecureExec.tools = require('./tools.js'); SecureExec.sync = require('./sync.js'); SecureExec.async = require('./async.js'); module.exports = SecureExec; × Search results Close "},"async.js.html":{"id":"async.js.html","title":"Source: async.js","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Source: async.js var dep = {}; dep.tools = require('./tools.js'); dep.exception = require('./exception.js'); dep.sync = require('./sync.js'); /** * @namespace SecureExec.async * */ var async = {}; var _async = {}; var _inner = {}; /** * Call a function @fn asynchronously, and pass the return value as an argument * to @callback. * &lt;br /&gt; * If an error occurs, this return value will be an instance * of {@link SecureExec.exception.Exception}. * &lt;br /&gt; * All parameters after @fn and @callback will be passed as arguments to @fn. * @param {function} fn - Function to call. * @param {function} callback - Callback to call with the return value of @fn * as an argument (or an instance of {@link SecureExec.exception.Exception}). * @returns {boolean} Returns false if @fn or @callback are not valid * functions. Otherwise, returns true. * @memberof SecureExec.async * @function * @name call * */ async.call = function(fn, callback){ if(typeof fn!=='function' || typeof callback!=='function'){ return false; } var args = dep.tools.proto.func.arrayFromArgumentsObject(arguments); args.shift(); // remove fn args.shift(); // remove callback setTimeout(function(){ var res = dep.tools.proto.func.apply(fn, args); setTimeout(function(){ callback(res); }, 0); }, 0); return true; }; /** * Call a function @fn asynchronously, and pass the return value as an argument * to @callback. * &lt;br /&gt; * If an error occurs, this return value will be an instance * of {@link SecureExec.exception.Exception}. * &lt;br /&gt; * The @args object must be a function's arguments object, or an array. * @param {function} fn - Function to call. * @param {function} callback - Callback to call with the return value of @fn * as an argument (or an instance of {@link SecureExec.exception.Exception}). * @param {object|Array} args - Will be passed to @fn as an array of arguments. * @returns {boolean} Returns false if @fn or @callback are not valid * functions, or if @args isn't an arguments object or array. Otherwise, * returns true. * @memberof SecureExec.async * @function * @name apply * */ async.apply = function(fn, callback, args){ if(typeof fn!=='function' || typeof callback!=='function'){ return false; } if(typeof args==='undefined'){ return false; } if(typeof args==='object'){ try{ args=dep.tools.proto.func.arrayFromArgumentsObject(args); }catch(e){ return false; } } if(dep.tools.proto.arr.isArray(args)!==true){ return false; } setTimeout(function(){ var res = dep.tools.proto.func.apply(fn, args); setTimeout(function(){ callback(res); }, 0); }, 0); return true; }; /** * Repeatedly call @task with @args as an argument, until its * property `args.complete` is `true`. * &lt;br /&gt; * Calls @final_callback when `args.complete` is `true`, or if an error occurs. * &lt;br /&gt; * The @task needs to take one object as an argument ( @args ) which has * parameters for the @task function, and return such an object so it can be * passed to the next run of @task. * &lt;br /&gt; * When @task shouldn't be repeated anymore, set the * property `(args).complete=true` before returning the object. * &lt;br /&gt; * If an error occurs, the @final_callback will be called with the * exception object immediately (see {@link SecureExec.exception.Exception}). * @param {function} task - Task to repeat. * @param {function} final_callback - Function to call after repetition is done. * Needs to take one object as an argument, which either is the arguments * object last returned, or an instance * of {@link SecureExec.exception.Exception} if an error occurs. * @param {object} args - Object which provides arguments for @task as * properties. Please note this function uses a property * from @args, `(args).complete`, internally. If @task returns an object with * a property `complete===true`, the task will not be * called any longer and @final_callback will be called with this * returned object as an argument. * @memberof SecureExec.async * @function * @name until * */ async.until = function(task, final_callback, args){ if(typeof task!=='function' || typeof final_callback!=='function'){ var e = new dep.exception.Exception(\"InvalidType\", \"task\"+ \"and final_callback must be functions for \"+ \"async.until!\"); setTimeout(function(){ final_callback(e); }, 0); return; } if(typeof args!=='object'){ var e = new dep.exception.Exception(\"InvalidType\", \"args\"+ \"must be an object for \"+ \"async.until!\"); setTimeout(function(){ final_callback(e); }, 0); return; } if(dep.tools.proto.inst.isException(args)){ setTimeout(function(){ final_callback(args); }, 0); return; } if(typeof args.complete!=='undefined' &amp;&amp; args.complete === true){ setTimeout(function(){ final_callback(args); }, 0); return; } setTimeout(function(){ args = [ args ]; args = dep.tools.proto.func.apply(task, args); setTimeout(function(){ async.until(task, final_callback, args); }, 0); }, 0); }; /** * This function works similarly to {@link SecureExec.async.waterfall}, but * allows including functions which should be repeated like * in {@link SecureExec.async.until}. * &lt;br /&gt; * Tasks which should be called like other tasks * in {@link SecureExec.async.waterfall} need to be passed in @tasks just as * functions. * &lt;br /&gt; * Tasks which should be repeated like in {@link SecureExec.async.until} need * to be objects like `{ 'func': {function} fn, 'repeat': {boolean} true }`. * &lt;br /&gt; * When repetition is done, the next item in @tasks will be called with the * return value of the last iteration, like the final callback * of {@link SecureExec.async.until} would be. * @param {Array} tasks * @param {function} final_callback * @memberof SecureExec.async * @function * @name waterfallUntil * */ async.waterfallUntil = function(tasks, final_callback){ _inner.waterfallUntil.callFunction.apply(null, arguments); }; _inner.waterfallUntil = {}; _inner.waterfallUntil.callFunction = function(tasks, final_callback){ var get_args = function(tasks, final_callback){ if(typeof final_callback!=='function'){ throw new Error(\"final_callback must be a function for \"+ \"async.waterfallUntil.\"); } if(dep.tools.proto.arr.isArray(tasks)!==true){ throw new Error(\"tasks must be an array for \"+ \"async.waterfallUntil.\"); } var tmp = dep.tools.proto.func.arrayFromArgumentsObject( arguments); tmp = tmp.slice(2); var args = [ tasks, final_callback, 0 ].concat(tmp); return args; }; var args = dep.tools.proto.func.apply(get_args, arguments); if(dep.tools.proto.inst.isException(args)){ setTimeout(function(){ final_callback(args); }, 0); return; } var res = dep.tools.proto.func.apply( _inner.waterfallUntil.runFunction, args); if(dep.tools.proto.inst.isException(res)){ setTimeout(function(){ final_callback(res); }, 0); return; } }; _inner.waterfallUntil.runFunction = function(tasks, final_callback, count){ var get_args = function(tasks, final_callback, count){ if(typeof count!=='number'){ throw new Error( \"Internal error in async.waterfallUntil: \"+ \"count is not a number.\"); } if(typeof final_callback!=='function'){ throw new Error(\"final_callback must be a function for \"+ \"async.waterfallUntil.\"); } var task = tasks[count]; var task_obj = ( typeof task==='object' &amp;&amp; ( typeof task.repeat==='boolean' &amp;&amp; typeof task.func==='function' ) ); var task_func = (typeof task==='function'); var task_not_valid = !(task_obj || task_func); if(task_not_valid &amp;&amp; count&lt;tasks.length){ throw new Error(\"All tasks must be a function for \"+ \"async.waterfallUntil, task \"+count+ \" does not seem to be one.\"); } var args = dep.tools.proto.func.arrayFromArgumentsObject( arguments); if(dep.tools.proto.inst.isException(args)){ return args; } args = args.slice(3); return args; }; var args = dep.tools.proto.func.apply(get_args, arguments); if(dep.tools.proto.inst.isException(args)){ setTimeout(function(){ final_callback(args); }, 0); return; } if(count &gt;= tasks.length){ setTimeout(function(){ dep.tools.proto.func.apply(final_callback, args); }, 0); return; } var task = tasks[count]; setTimeout(function(){ if(typeof task==='object'){ task = task.func; if(typeof args[0]==='object' &amp;&amp; typeof args[0].complete==='boolean' &amp;&amp; args[0].complete===true){ count+=1; }else{ args = dep.tools.proto.func.apply(task, args); if(dep.tools.proto.inst.isException(args)){ setTimeout(function(){ final_callback(args); }, 0); return; } } }else{ count+=1; args = dep.tools.proto.func.apply(task, args); if(dep.tools.proto.inst.isException(args)){ setTimeout(function(){ final_callback(args); }, 0); return; } } setTimeout(function(){ args = [ tasks, final_callback, count ].concat(args); //_async.waterfallUntil.apply(null,args); dep.tools.proto.func.apply( _inner.waterfallUntil.runFunction, args); }, 0); }, 0); }; /** * Runs the @tasks array of functions in series, each passing their results to * the next in the array. However, if any of the tasks returns an exception * (instance of {@link SecureExec.exception.Exception}), the next function is * not executed, and the @final_callback is immediately called with an * instance of {@link SecureExec.exception.Exception} as an argument. * &lt;br /&gt; * Parameters after @tasks and @final_callback will be used as parameters for * the first function (@tasks[0]). * @param {function[]} tasks - Array of functions. * @param {function} final_callback - Final callback. * @memberof SecureExec.async * @function * @name waterfall * */ async.waterfall = function(tasks, final_callback){ //_inner.waterfall.callFunction.apply(null, arguments); var check_tasks = function(tasks){ if(!dep.tools.proto.arr.isArray(tasks)){ throw new Error(\"tasks must be an array for \"+ \"async.waterfall!\"); } for(var i=0; i&lt;tasks.length; i++){ if(typeof tasks[i]!=='function'){ throw new Error(\"Each task must be a function!\"+ \"async.waterfall!\"); } } return true; }; var tasks_val = dep.sync.apply(check_tasks, [tasks]); if(dep.tools.proto.inst.isException(tasks_val)){ final_callback(tasks_val); return; } async.waterfallUntil.apply(null,arguments); }; /** * Call a series of asynchronous function calls. * &lt;br /&gt; * This is intended to wrap up several asynchronous calls, i.e. functions * which will call a callback. * &lt;br /&gt; * Functions in the series will NOT be executed securely, if they throw * exceptions, these won't be caught. * &lt;br /&gt; * Therefore, this function makes most sense to combine functions which are * asynchronous function calls via `SecureExec.async` (i.e., wrap a `waterfall` * or `until` call) or functions which are not likely to throw exceptions. * &lt;br /&gt; * Each function in the array of tasks needs to take two arguments, * like `function(auto_args, args)`. The `args` object is intended to carry * function arguments, while the `auto_args` argument shouldn't be changed * manually. * &lt;br /&gt; * Instead of returning the arguments object `args`, a task should * call `auto_args.callback(args)`. * &lt;br /&gt; * The final callback will be called after all tasks are completed, with * like `final_callback(args)`. * &lt;br /&gt; * If invalid arguments are found, it will be called * like `final_callback({SecureExec.Exception} exp, {\\*} args)`. * &lt;br /&gt; * To call the final callback earlier (for example, after an exception was * detected manually), * call `(auto_args).final_callback({SecureExec.Exception} exp, {\\*} args)`. * @param {object} call_args - Object like `{'tasks': {function[] * array_of_functions, 'final_callback': {function} final_callback}`. * @param {*} args - Passed as an actual argument to the first function in * the array. Each function in array must take arguments like `function({object} * auto_args, {\\*} args)`, where `auto_args` should not be changed manually. * @function * @name insecureSeries * @memberof SecureExec.async * */ async.insecureSeries = function(call_args, args){ var callback = async.insecureSeries; _inner.insecureSeries.callFunction(call_args, callback, args); }; _inner.insecureSeries = {}; _inner.insecureSeries.callFunction = function(call_args, callback, args){ var check = function(call_args, callback, args){ var tasks = call_args.tasks; var count = call_args.count; var final_callback = call_args.final_callback; var msg = \"Invalid argument for async.insecureSeries: \"; if(typeof tasks==='undefined' || dep.tools.proto.arr.isArray(tasks)!==true){ throw new Error(msg+\"@tasks is not an array!\"); } if(typeof count!=='number'){ throw new Error(msg+\"@count is not a number!\"); } if(typeof final_callback!=='function'){ throw new Error(msg+\"@final_callback is not a function!\"); } if(count&gt;tasks.length &amp;&amp; typeof tasks[count]==='undefined'){ throw new Error(msg+\"@tasks[\"+count+\"] is not defined!\"); } if(count&gt;tasks.length &amp;&amp; typeof tasks[count]!=='function'){ throw new Error(msg+\"@tasks[\"+count+\"] is not a function!\"); } /*if(typeof tasks[count].fn!==\"function\"){ throw new Error(msg+\"@tasks[\"+count+\"].fn is not a function!\"); } if(typeof tasks[count].callback!==\"function\"){ throw new Error(msg+ * \"@tasks[\"+count+\"].callback is not a function!\"); }*/ if(count&gt;0 &amp;&amp; typeof callback!=='function'){ throw new Error(msg+\"@callback is not a function!\"); } if(typeof args==='undefined'){ args = {}; } return [call_args, callback, args]; }; var fn_args = dep.tools.proto.func.apply(check, arguments); if(dep.tools.proto.inst.isException(args)){ setTimeout(function(){ call_args.final_callback(args); }, 0); return; } if(dep.tools.proto.inst.isException(fn_args)){ setTimeout(function(){ call_args.final_callback(fn_args); }, 0); return; } _inner.insecureSeries.runFunction.apply(null, fn_args); }; _inner.insecureSeries.runFunction = function(call_args, callback, args){ var tasks = call_args.tasks; var count = call_args.count; var final_callback = call_args.final_callback; if(typeof tasks[count]==='function'){ var task = tasks[count]; call_args.count += 1; call_args.callback = callback; setTimeout(function(){ task(call_args, args); }, 0); }else{ setTimeout(function(){ final_callback(args); }, 0); } }; module.exports = async; × Search results Close "},"exception.js.html":{"id":"exception.js.html","title":"Source: exception.js","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Source: exception.js var dep = {}; dep.stack = require('./stack.js'); /** * @namespace SecureExec.exception * */ var exception = {}; var _exception = {}; var _instOf = function(obj, inst){ try{ if(typeof obj==='undefined' || typeof inst==='undefined'){ return false; } if(obj instanceof inst){ return true; } }catch(e){ return false; } }; var _isArr = function(arg){ var is_array = Array.isArray || function(arg) { return Object.prototype.toString.callFunction(arg) === '[object Array]'; }; return is_array(arg); }; /** * Constructor for a custom `SecureExec` exception. Instances of this class will * be just objects (instances of `SecureExec.exception.Exception`, not * Javascript errors. * &lt;br /&gt; * If you specify @name and/or @message, these name and error message will * always be used, no matter whether @error is defined or not. * &lt;br /&gt; * With the optional @error property, an actual Javascript exception can be * passed. If name and/or message aren't specified (i.e. `null` or empty * strings), name and message from @error will be used. * &lt;br /&gt; * A custom @stack array can be passed to set a custom stack trace. This * stack trace will be merged with the stacktrace generated, or if @error is * specified, the stacktrace from @error. If @stack is not specified, the * stacktrace from @error or the stacktrace generated will be used. (This * should usually be the case, if there's no reason for a custom additional * stacktrace.) * @typedef {Object} SecureExec.exception.Exception * @param {string} [name=\"Exception\"] - Name of the exception. * @param {string} [message=\"Exception occured.\"] - Exception message. * @param {object} [error=null] - Javascript exception to get exception from. * To get the name and message of @error, pass null for @name and @message. * @param {string[]} [stack] - Custom stack trace. * @returns {SecureExec.exception.Exception} * @memberof SecureExec.exception * @class * @name Exception * */ exception.Exception = function(name, message, error, stack){ var exp = new _exception.constructException(name, message, error, stack); /** * @name name * @member {string} * @memberof SecureExec.exception.Exception# * */ this.name = exp.name; /** * @name message * @member {string} * @memberof SecureExec.exception.Exception# * */ this.message = exp.message; /** * @name error * @member {Error} * @memberof SecureExec.exception.Exception# * */ this.error = exp.error; /** * @name stack * @member {string[]} * @memberof SecureExec.exception.Exception# * */ this.stack = exp.stack; }; _exception.constructException = function(name, message, error, stack){ this.name = \"Exception\"; this.message = \"Exception occured.\"; this.error = null; this.stack = []; /* Check whether there is a custom stack trace yet. */ if(_isArr(stack)!==true){ stack = []; } /* Get properties from @error if defined. */ var err_name = null; var err_msg = null; if(_instOf(error, Error)){ err_name = error.name || null; err_msg = error.message || null; var err_stack = dep.stack.getStackTrace(error); stack = stack.concat(err_stack); } /* Get stacktrace if there's now @error */ else{ stack = dep.stack.getStackTrace(); } /* Get the exception name. */ if(typeof err_name==='string' &amp;&amp; err_name.length&gt;0){ if(typeof name!=='string' || name.length&lt;1){ name = err_name; } } /* Get the exception message. */ if(typeof err_msg==='string'){ if(typeof message!=='string'){ message = err_msg; } } /* Get the properties */ if(typeof name==='string' &amp;&amp; name.length&gt;0) this.name = name; if(typeof message==='string') this.message = message; if(_instOf(error, Error)) this.error = error; this.stack = stack; }; module.exports = exception; × Search results Close "},"stack.js.html":{"id":"stack.js.html","title":"Source: stack.js","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Source: stack.js var stacktraceJS = require('stacktrace-js'); /** * @namespace SecureExec.stack * */ var stack = {}; var _stack = {}; var _inner = {}; /** * Get a stack trace for a custom exception, or a generate one at the point * where this function is called. * &lt;br /&gt; * The stack trace will be an array of strings, which is empty if any exception * occurs creating the stacktrace. * @param {Error} [e] - Optional Javascript error object. If this is passed, * the stacktrace will be generated from the stack trace information found in * this object. * @returns {string[]} * @memberof SecureExec.stack * @function * @name getStackTrace * */ stack.getStackTrace = function(e){ return _inner.getStackTrace.call(e); }; _inner.getStackTrace = {}; _inner.getStackTrace.call = function(e){ try{ return _inner.getStackTrace.run(e); }catch(e){ SecureExec.tools.log.consoleLog(\"Exception occured in \"+ \"SecureExec.stack.getStackTrace: \"); SecureExec.tools.log.consoleLog(e); return []; } }; _inner.getStackTrace.run = function(e){ var stack = []; var getStackFromE = false; try{ getStackFromE = ((typeof e==='object') &amp;&amp; (e instanceof Error)); }catch(e){} if(getStackFromE===true){ stack = stacktraceJS({'e': e}); }else{ stack = stacktraceJS(); } return stack; }; /* Use 'stacktrace-js' instead of functions which easily outdate. * The stacktrace-js devs will keep it current? *g* */ /*_inner.getStackTrace.run = function(e){ var remove_last = false; if( typeof e!==\"object\" || e===null || (e instanceof Error)!==true ){ remove_last = true; try{ throw new Error(); }catch(err){ e = err; } } /* Get stack */ /*var callstack = []; var isCallstackPopulated = false; // Stack in browsers supporting e.stack if (e.stack) { //Firefox var lines = e.stack.split('\\n'); for (var i=0, len=lines.length; i&lt;len; i++) { if (typeof lines[i]===\"string\" &amp;&amp; lines[i].length&gt;0) { callstack.push(lines[i]); } } //Remove call to get stack trace function if(remove_last===true){ for(var ct=0; ct&lt;3; ct++) callstack.shift(); } isCallstackPopulated = true; } // Older opera if(isCallstackPopulated===false &amp;&amp; (window.opera &amp;&amp; e.message)){ var lines = e.message.split('\\n'); for (var i=0, len=lines.length; i&lt;len; i++) { if (typeof lines[i]===\"string\" &amp;&amp; lines[i].length&gt;0) { var entry = lines[i]; //Append next line also since it has the file info if (lines[i+1]) { entry += ' at ' + lines[i+1]; i++; } callstack.push(entry); } } //Remove call to get stack trace function if(remove_last===true){ for(var ct=0; ct&lt;3; ct++) callstack.shift(); } isCallstackPopulated = true; } //IE and Safari if (isCallstackPopulated===false) { var currentFunction = arguments.callee.caller; while (currentFunction) { var fn = currentFunction.toString(); var fname = fn.substring(fn.indexOf(\"function\") + 8, fn.indexOf('')) || 'anonymous'; callstack.push(fname); currentFunction = currentFunction.caller; } } return callstack; };*/ module.exports = stack; × Search results Close "},"sync.js.html":{"id":"sync.js.html","title":"Source: sync.js","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Source: sync.js var dep = {}; dep.tools = require('./tools.js'); dep.exception = require('./exception.js'); /** * @namespace SecureExec.sync * */ var sync = {}; var _sync = {}; /** * Apply a function securely, i.e. without throwing actual Javascript errors if * anything breaks. * &lt;br /&gt; * This calls a function synchronously and either returns the functions return * value, or an instance of {@link SecureExec.exception.Exception} if an error * occurs. * @param {function} - Function to apply. * @param {Array|Object} - Array of function parameters. This can be the * arguments object from another function, or a simple array of function * parameters. * @returns {*|SecureExec.exception.Exception} Return value of the function, * or (in case of an exception) instance * of {@link SecureExec.exception.Exception} * @memberof SecureExec.sync * @function * @name apply * */ sync.apply = function (fn, args) { return dep.tools.proto.func.apply(fn, args); }; /** * Call a function @fn synchronously. * &lt;br /&gt; * Returns the return value of @fn. * &lt;br /&gt; * If an error occurs, this return value will be an instance of * {@link SecureExec.exception.Exception}. * &lt;br /&gt; * All parameters after @fn will be passed as arguments to @fn. * @param {function} fn - Function to call. * @returns {*|SecureExec.exception.Exception} Return value of the function, * or an instance of {@link SecureExec.exception.Exception}. * @memberof SecureExec.sync * @function * @name call * */ sync.call = function(fn){ var args = dep.tools.proto.func.arrayFromArgumentsObject(arguments); args.shift(); // remove fn return dep.tools.proto.func.apply(fn, args); }; module.exports = sync; × Search results Close "},"tools.js.html":{"id":"tools.js.html","title":"Source: tools.js","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Source: tools.js var dep = {}; dep.exception = require('./exception.js'); /** * @namespace SecureExec.tools * */ var tools = {}; var _tools = {}; var _inner = {}; /** * @namespace SecureExec.tools.proto * */ tools.proto = {}; _tools.proto = {}; _inner.proto = {}; /** * @namespace SecureExec.tools.proto.inst * */ tools.proto.inst = {}; _tools.proto.inst = {}; _inner.proto.inst = {}; /** * This function is a convenience wrapper for `instanceof`. It checks whether an * object is an instance of a class, but doesn't throw exceptions if for * example the instance argument is undefined. * &lt;br /&gt; * This function will return `true` if @obj is an instance of @inst, and `false` * if not so, or if an error occurs. * @param {object} obj - Object to check if it is an instance of @inst. * @param {function} inst - Class to check whether @inst is an instance of. * @returns {boolean} * @memberof SecureExec.tools.proto.inst * @function * @name isInstanceOf * */ tools.proto.inst.isInstanceOf = function(obj, inst){ return _inner.proto.inst.isInstanceOf.callFunction(obj, inst); }; _inner.proto.inst.isInstanceOf = {}; _inner.proto.inst.isInstanceOf.callFunction = function(obj, inst){ try{ return _inner.proto.inst.isInstanceOf.runFunction(obj, inst); }catch(e){ return false; } }; _inner.proto.inst.isInstanceOf.runFunction = function(obj, inst){ if(typeof obj==='undefined' || typeof inst==='undefined'){ return false; } if(obj instanceof inst){ return true; } return false; }; /** * Checks whether an object is an instance of the `SecureExec` custom exception * type {@link SecureExec.exception.Exception}. * &lt;br /&gt; * Please note this function will not return `true` on plain Javascript errors / * exceptions but is for checking for an instance of * {@link SecureExec.exception.Exception}. * @param {object} e - Object to check whether is a {@link SecureExec.exception.Exception}. * @returns {boolean} * @memberof SecureExec.tools.proto.inst * @function * @name isException * */ tools.proto.inst.isException = function(e){ return tools.proto.inst.isInstanceOf(e, dep.exception.Exception); }; /** * This function checks whether @e is an instance of Error, i.e. whether @e * is a normal Javascript error. * @param {object} e - Object to check whether this is a Javascript error. * @returns {boolean} * @memberof SecureExec.tools.proto.inst * @function * @name isError * */ tools.proto.inst.isError = function(e){ return tools.proto.inst.isInstanceOf(e, Error); }; /** * @namespace SecureExec.tools.proto.func * */ tools.proto.func = {}; _tools.proto.func = {}; _inner.proto.func = {}; /** * Converts the arguments object from a function into a simple array of the * parameters. * @param {object} - Arguments object from a function. * @returns {Array} - Array of parameters. * @memberof SecureExec.tools.proto.func * @function * @name arrayFromArgumentsObject * */ tools.proto.func.arrayFromArgumentsObject = function(arg){ return _inner.proto.func.argumentsArrayFromObject.callFunction(arg); }; _inner.proto.func.argumentsArrayFromObject = {}; _inner.proto.func.argumentsArrayFromObject.callFunction = function(arg){ try{ return _inner.proto.func.argumentsArrayFromObject.runFunction(arg); }catch(e){ var exp = new dep.exception.Exception(null,null,e); return exp; } }; _inner.proto.func.argumentsArrayFromObject.runFunction = function(arg){ var i=0; var arr = []; while(typeof arg[i]!=='undefined'){ arr.push(arg[i]); i+=1; } return arr; }; /** * Apply a function securely, i.e. without throwing actual Javascript errors if * anything breaks. * &lt;br /&gt; * This calls a function synchronously and either returns the functions return * value, or an instance of {@link SecureExec.exception.Exception} if an error * occurs. * @param {function} - Function to apply. * @param {Array|Object} - Array of function parameters. This can be the * arguments object from another function, or a simple array of function * parameters. * @returns {*|SecureExec.exception.Exception} * @memberof SecureExec.tools.proto.func * @function * @name apply * */ tools.proto.func.apply = function(fn, args){ return _inner.proto.func.apply.callFunction(fn, args); }; _inner.proto.func.apply = {}; _inner.proto.func.apply.callFunction = function(fn, args){ try{ return _inner.proto.func.apply.runFunction(fn, args); }catch(e){ var exp = new dep.exception.Exception(null,null,e); return exp; } }; _inner.proto.func.apply.runFunction = function(fn, args){ var apply_args = args; apply_args = tools.proto.func.arrayFromArgumentsObject(apply_args); if(tools.proto.inst.isException(apply_args)){ return apply_args; } if(typeof fn!=='function'){ // exception, need a function here throw new Error('fn must be a function to apply!'); } if(tools.proto.arr.isArray(apply_args)!==true){ // exception, need an array here throw new Error('args must be an array!'); } return fn.apply(null, apply_args); }; /** * @namespace SecureExec.tools.proto.arr * */ tools.proto.arr = {}; _tools.proto.arr = {}; _inner.proto.arr = {}; /** * Check whether @arg is an array. * @param {*} arg - Check if @arg is an array. * @returns {boolean} * @memberof SecureExec.tools.proto.arr * @function * @name isArray * */ tools.proto.arr.isArray = function(arg){ return _inner.proto.arr.isArray.callFunction(arg); }; _inner.proto.arr.isArray = {}; _inner.proto.arr.isArray.callFunction = function(arg){ try{ return _inner.proto.arr.isArray.runFunction(arg); }catch(e){ var exp = new dep.exception.Exception(null,null,e); return exp; } }; _inner.proto.arr.isArray.runFunction = function(arg){ var is_array = Array.isArray || function(arg) { return Object.prototype.toString.callFunction(arg) === '[object Array]'; }; return is_array(arg); }; /** * Get the unique elements in an array, i.e. remove duplicates. * @param {Array} - Array to get unique elements in. * @returns {Array|Object} Returns an array with duplicates removed, or an * instance of {@link SecureExec.exception.Exception}. * @memberof SecureExec.tools.proto.arr * @function * @name isArray * */ tools.proto.arr.uniq = function(arr){ return _inner.proto.arr.uniq.callFunction(arr); }; _inner.proto.arr.uniq = {}; _inner.proto.arr.uniq.callFunction = function(arr){ try{ return _inner.proto.arr.uniq.runFunction(arr); }catch(e){ var exp = new dep.exception.Exception(null,null,e); return exp; } }; _inner.proto.arr.uniq.runFunction = function(arr){ /* From: * https://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array * */ var prims = {'boolean':{}, 'number':{}, 'string':{}}, objs = []; return a.filter(function(item) { var type = typeof item; if(type in prims) return prims[type].hasOwnProperty(item) ? false : (prims[type][item] = true); else return objs.indexOf(item) &gt;= 0 ? false : objs.push(item); }); }; /** * @namespace SecureExec.tools.log * */ tools.log = {}; _tools.log = {}; _inner.log = {}; /** * Log a string to Javascript console if one is available. * @param {*} to_log - Object to log. * @memberof SecureExec.tools.log * @function * @name consoleLog * */ tools.log.consoleLog = function(to_log){ if(typeof console!=='undefined' &amp;&amp; typeof console.log==='function'){ try{ console.log(to_log); }catch(e){} } }; module.exports = tools; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Classes Classes Exception Namespaces SecureExec async exception stack sync tools log proto arr func inst × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Namespaces Classes Exception Namespaces SecureExec async exception stack sync tools log proto arr func inst × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception SecureExecSecureExec is a very small Javascript library which allows calling functions without throwing actual Javascript exceptions. Applying functions using the SecureExec function call methods results in functions no longer throwing exceptions. Instead, a function will return a custom SecureExec exception object if an error occurs inside the function. Then all you need to do is to check whether the return value is such an exception object to know whether an error has occured. This works for asynchronously called functions just as well, of course - the callback will simply be passed the exception object. In addition, SecureExec has some asynchronous control flow functions which allow calling asynchronous functions more conveniently, as well as functions to generate stacktraces and custom exception objects. ExamplesCalling a function securelyTo call a function securely, use SecureExec.sync.apply or SecureExec.sync.call. (See the documentation for details. apply takes an array or arguments, while call takes an argument list - that's the difference.) Calling the function using SecureExec.sync.apply: var fn = function(a,b,c,d){ return a+b+c+d; }; var a=\"a\"; var b=\"b\"; var c=\"c\"; var d=\"d\"; var res = SecureExec.sync.apply(fn, [a,b,c,d]); if(SecureExec.tools.proto.inst.isException(res)){ // an exception has occured here }Now calling the function using SecureExec.sync.call: var fn = function(a,b,c,d){ return a+b+c+d; }; var a=\"a\"; var b=\"b\"; var c=\"c\"; var d=\"d\"; var res = SecureExec.sync.call(fn, a, b, c, d); if(SecureExec.tools.proto.inst.isException(res)){ // an exception has occured here }Throw an error inside the example function to take a look at the exception object. Calling a function securely (asynchronously)To call a function asynchronously, use SecureExec.async.call and SecureExec.async.apply. These functions work in a pretty simple way: The function is called securely asynchronously, and its return value is passed to the callback. With apply: var fn = function(a,b,c,d){ // do some stuff return a+b+c+d; }; var done = function(res){ if(SecureExec.tools.proto.inst.isException(res)!==true &amp;&amp; res===\"abcd\"){ // this has worked }else{ // there's been an exception } }; var a=\"a\"; var b=\"b\"; var c=\"c\"; var d=\"d\"; SecureExec.async.apply(fn, done, [a,b,c,d]);... or with call: var fn = function(a,b,c,d){ // do some stuff return a+b+c+d; }; var done = function(res){ if(SecureExec.tools.proto.inst.isException(res)!==true &amp;&amp; res===\"abcd\"){ // this has worked }else{ // an exception has occured } }; var a=\"a\"; var b=\"b\"; var c=\"c\"; var d=\"d\"; SecureExec.async.call(fn, done, a, b, c, d);Asynchronous control flowSecureExec has some functions which simplify asynchronous function calls. (However, only few, at the moment.) until repeats a function until the object returned has a property {boolean} obj.complete === true. var fn = function(args){ if(typeof args.count!==\"number\"){ args.count = 0; } args.count += 1; if(args.count===10){ args.complete = true; } return args; }; var done = function(res){ if(SecureExec.tools.proto.inst.isException(res)){ // an exception has occured } if(typeof res.count===\"number\" &amp;&amp; res.count===10){ // it has worked } }; SecureExec.async.until(fn, done, {});waterfall calls an array of tasks, with each function being passed the return value of the function called before. (The first function will be called with custom arguments.) If an error occurs, the final callback is called earlier with the exception object. (Arguments are passed like in call - the function arguments for the first function are the additional arguments for waterfall.) var f1 = function(a,b,c){ return a+b+c; }; var f2 = function(a){ return a+\"d\"; }; var f3 = function(a){ return a+\"e\"; }; var f4 = function(a){ return a+\"f\"; }; var done = function(res){ if(SecureExec.tools.proto.inst.isException(res)){ // an exception has occured } if(res!==\"abcdef\"){ // everything worked here } }; SecureExec.async.until([f1,f2,f3,f4], done, \"a\",\"b\",\"c\");The Exception classException objects in SecureExec are instances of the SecureExec.exception.Exception class. Exception objects try to be easier to handle than plain Javascript errors. Each exception has a name, a message, and a stacktrace (which, hopefully, is filled in any somewhat decent browser). If an exception was generated from an actual Javascript error, it's error property contains this error (by default it's null). Exceptions aren't thrown, but simply returned as return values of functions which originally would have thrown an error. Please note: This also means that your function should only return a (customly built) exception if you actually intend this function to return an exception. (You might do this instead of throwing an error in the function to control exception name and message more easily. A stacktrace will still be generated.) Working with exception objects instead of classical errors means you won't have to handle errors using window.onerror or catch exceptions in every function as long as you call functions which might throw errors using the call functions in SecureExec. Any exception thrown will be caught in SecureExec. However, after a function returns, check whether the return value is a SecureExec.exception.Exception. If so, handle the exception properly. StacktracesFor each instance of SecureExec.exception.Exception, a stack trace will be generated. However, a stacktrace can be generated at any point of the program without an exception object. To generate a stacktrace manually, use SecureExec.stack.getStackTrace. This function either simply generates a stacktrace at a certain point of the program, or a stacktrace from a Javascript error object (not a SecureExec exception object). SecureExec.stack.getStackTrace returns the stack trace as browser-independent and simple as possible, so you should receive an array of strings which is not the same for every browser, but at least get a filled stacktrace in any (somewhat modern) browser. Building the docsTo build the docs, run npm run generate-docs. LicenseSecureExec is released under the MIT License. × Search results Close "},"SecureExec.html":{"id":"SecureExec.html","title":"Namespace: SecureExec","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Namespace: SecureExec SecureExec Source: secureexec.js, line 1 Namespaces async exception stack sync tools × Search results Close "},"SecureExec.async.html":{"id":"SecureExec.async.html","title":"Namespace: async","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Namespace: async SecureExec. async Source: async.js, line 6 Methods &lt;static&gt; apply(fn, callback, args) Call a function @fn asynchronously, and pass the return value as an argument to @callback. If an error occurs, this return value will be an instance of SecureExec.exception.Exception. The @args object must be a function's arguments object, or an array. Parameters: Name Type Description fn function Function to call. callback function Callback to call with the return value of @fn as an argument (or an instance of SecureExec.exception.Exception). args object | Array Will be passed to @fn as an array of arguments. Source: async.js, line 46 Returns: Returns false if @fn or @callback are not valid functions, or if @args isn't an arguments object or array. Otherwise, returns true. Type boolean &lt;static&gt; call(fn, callback) Call a function @fn asynchronously, and pass the return value as an argument to @callback. If an error occurs, this return value will be an instance of SecureExec.exception.Exception. All parameters after @fn and @callback will be passed as arguments to @fn. Parameters: Name Type Description fn function Function to call. callback function Callback to call with the return value of @fn as an argument (or an instance of SecureExec.exception.Exception). Source: async.js, line 13 Returns: Returns false if @fn or @callback are not valid functions. Otherwise, returns true. Type boolean &lt;static&gt; insecureSeries(call_args, args) Call a series of asynchronous function calls. This is intended to wrap up several asynchronous calls, i.e. functions which will call a callback. Functions in the series will NOT be executed securely, if they throw exceptions, these won't be caught. Therefore, this function makes most sense to combine functions which are asynchronous function calls via SecureExec.async (i.e., wrap a waterfall or until call) or functions which are not likely to throw exceptions. Each function in the array of tasks needs to take two arguments, like function(auto_args, args). The args object is intended to carry function arguments, while the auto_args argument shouldn't be changed manually. Instead of returning the arguments object args, a task should call auto_args.callback(args). The final callback will be called after all tasks are completed, with like final_callback(args). If invalid arguments are found, it will be called like final_callback({SecureExec.Exception} exp, {\\*} args). To call the final callback earlier (for example, after an exception was detected manually), call (auto_args).final_callback({SecureExec.Exception} exp, {\\*} args). Parameters: Name Type Description call_args object Object like {'tasks': {function[] array_of_functions, 'final_callback': {function} final_callback}. args * Passed as an actual argument to the first function in the array. Each function in array must take arguments like function({object} auto_args, {\\*} args), where auto_args should not be changed manually. Source: async.js, line 330 &lt;static&gt; until(task, final_callback, args) Repeatedly call @task with @args as an argument, until its property args.complete is true. Calls @final_callback when args.complete is true, or if an error occurs. The @task needs to take one object as an argument ( @args ) which has parameters for the @task function, and return such an object so it can be passed to the next run of @task. When @task shouldn't be repeated anymore, set the property (args).complete=true before returning the object. If an error occurs, the @final_callback will be called with the exception object immediately (see SecureExec.exception.Exception). Parameters: Name Type Description task function Task to repeat. final_callback function Function to call after repetition is done. Needs to take one object as an argument, which either is the arguments object last returned, or an instance of SecureExec.exception.Exception if an error occurs. args object Object which provides arguments for @task as properties. Please note this function uses a property from @args, (args).complete, internally. If @task returns an object with a property complete===true, the task will not be called any longer and @final_callback will be called with this returned object as an argument. Source: async.js, line 85 &lt;static&gt; waterfall(tasks, final_callback) Runs the @tasks array of functions in series, each passing their results to the next in the array. However, if any of the tasks returns an exception (instance of SecureExec.exception.Exception), the next function is not executed, and the @final_callback is immediately called with an instance of SecureExec.exception.Exception as an argument. Parameters after @tasks and @final_callback will be used as parameters for the first function (@tasks[0]). Parameters: Name Type Description tasks Array.&lt;function()&gt; Array of functions. final_callback function Final callback. Source: async.js, line 292 &lt;static&gt; waterfallUntil(tasks, final_callback) This function works similarly to SecureExec.async.waterfall, but allows including functions which should be repeated like in SecureExec.async.until. Tasks which should be called like other tasks in SecureExec.async.waterfall need to be passed in @tasks just as functions. Tasks which should be repeated like in SecureExec.async.until need to be objects like { 'func': {function} fn, 'repeat': {boolean} true }. When repetition is done, the next item in @tasks will be called with the return value of the last iteration, like the final callback of SecureExec.async.until would be. Parameters: Name Type Description tasks Array final_callback function Source: async.js, line 155 × Search results Close "},"SecureExec.exception.html":{"id":"SecureExec.exception.html","title":"Namespace: exception","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Namespace: exception SecureExec. exception Source: exception.js, line 4 Classes Exception × Search results Close "},"SecureExec.exception.Exception.html":{"id":"SecureExec.exception.Exception.html","title":"Class: Exception","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Class: Exception SecureExec.exception. Exception new Exception( [name] [, message] [, error] [, stack]) Constructor for a custom SecureExec exception. Instances of this class will be just objects (instances of SecureExec.exception.Exception, not Javascript errors. If you specify @name and/or @message, these name and error message will always be used, no matter whether @error is defined or not. With the optional @error property, an actual Javascript exception can be passed. If name and/or message aren't specified (i.e. null or empty strings), name and message from @error will be used. A custom @stack array can be passed to set a custom stack trace. This stack trace will be merged with the stacktrace generated, or if @error is specified, the stacktrace from @error. If @stack is not specified, the stacktrace from @error or the stacktrace generated will be used. (This should usually be the case, if there's no reason for a custom additional stacktrace.) Parameters: Name Type Argument Default Description name string &lt;optional&gt; \"Exception\" Name of the exception. message string &lt;optional&gt; \"Exception occured.\" Exception message. error object &lt;optional&gt; null Javascript exception to get exception from. To get the name and message of @error, pass null for @name and @message. stack Array.&lt;string&gt; &lt;optional&gt; Custom stack trace. Source: exception.js, line 29 Returns: Type SecureExec.exception.Exception Members error :Error Type: Error Source: exception.js, line 72 message :string Type: string Source: exception.js, line 66 name :string Type: string Source: exception.js, line 60 stack :Array.&lt;string&gt; Type: Array.&lt;string&gt; Source: exception.js, line 78 × Search results Close "},"SecureExec.stack.html":{"id":"SecureExec.stack.html","title":"Namespace: stack","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Namespace: stack SecureExec. stack Source: stack.js, line 3 Methods &lt;static&gt; getStackTrace( [e]) Get a stack trace for a custom exception, or a generate one at the point where this function is called. The stack trace will be an array of strings, which is empty if any exception occurs creating the stacktrace. Parameters: Name Type Argument Description e Error &lt;optional&gt; Optional Javascript error object. If this is passed, the stacktrace will be generated from the stack trace information found in this object. Source: stack.js, line 10 Returns: Type Array.&lt;string&gt; × Search results Close "},"SecureExec.sync.html":{"id":"SecureExec.sync.html","title":"Namespace: sync","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Namespace: sync SecureExec. sync Source: sync.js, line 5 Methods &lt;static&gt; apply() Apply a function securely, i.e. without throwing actual Javascript errors if anything breaks. This calls a function synchronously and either returns the functions return value, or an instance of SecureExec.exception.Exception if an error occurs. Parameters: Type Description function Function to apply. Array | Object Array of function parameters. This can be the arguments object from another function, or a simple array of function parameters. Source: sync.js, line 11 Returns: Return value of the function, or (in case of an exception) instance of SecureExec.exception.Exception Type * | SecureExec.exception.Exception &lt;static&gt; call(fn) Call a function @fn synchronously. Returns the return value of @fn. If an error occurs, this return value will be an instance of SecureExec.exception.Exception. All parameters after @fn will be passed as arguments to @fn. Parameters: Name Type Description fn function Function to call. Source: sync.js, line 33 Returns: Return value of the function, or an instance of SecureExec.exception.Exception. Type * | SecureExec.exception.Exception × Search results Close "},"SecureExec.tools.html":{"id":"SecureExec.tools.html","title":"Namespace: tools","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Namespace: tools SecureExec. tools Source: tools.js, line 4 Namespaces log proto × Search results Close "},"SecureExec.tools.log.html":{"id":"SecureExec.tools.log.html","title":"Namespace: log","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Namespace: log SecureExec.tools. log Source: tools.js, line 243 Methods &lt;static&gt; consoleLog(to_log) Log a string to Javascript console if one is available. Parameters: Name Type Description to_log * Object to log. Source: tools.js, line 250 × Search results Close "},"SecureExec.tools.proto.html":{"id":"SecureExec.tools.proto.html","title":"Namespace: proto","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Namespace: proto SecureExec.tools. proto Source: tools.js, line 11 Namespaces arr func inst × Search results Close "},"SecureExec.tools.proto.arr.html":{"id":"SecureExec.tools.proto.arr.html","title":"Namespace: arr","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Namespace: arr SecureExec.tools.proto. arr Source: tools.js, line 172 Methods &lt;static&gt; isArray() Get the unique elements in an array, i.e. remove duplicates. Parameters: Type Description Array Array to get unique elements in. Source: tools.js, line 206 Returns: Returns an array with duplicates removed, or an instance of SecureExec.exception.Exception. Type Array | Object &lt;static&gt; isArray(arg) Check whether @arg is an array. Parameters: Name Type Description arg * Check if @arg is an array. Source: tools.js, line 179 Returns: Type boolean × Search results Close "},"SecureExec.tools.proto.func.html":{"id":"SecureExec.tools.proto.func.html","title":"Namespace: func","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Namespace: func SecureExec.tools.proto. func Source: tools.js, line 90 Methods &lt;static&gt; apply() Apply a function securely, i.e. without throwing actual Javascript errors if anything breaks. This calls a function synchronously and either returns the functions return value, or an instance of SecureExec.exception.Exception if an error occurs. Parameters: Type Description function Function to apply. Array | Object Array of function parameters. This can be the arguments object from another function, or a simple array of function parameters. Source: tools.js, line 127 Returns: Type * | SecureExec.exception.Exception &lt;static&gt; arrayFromArgumentsObject() Converts the arguments object from a function into a simple array of the parameters. Parameters: Type Description object Arguments object from a function. Source: tools.js, line 97 Returns: Array of parameters. Type Array × Search results Close "},"SecureExec.tools.proto.inst.html":{"id":"SecureExec.tools.proto.inst.html","title":"Namespace: inst","body":" SecureExec Namespaces SecureExecSecureExec.asyncSecureExec.exceptionSecureExec.stackSecureExec.syncSecureExec.toolsSecureExec.tools.logSecureExec.tools.protoSecureExec.tools.proto.arrSecureExec.tools.proto.funcSecureExec.tools.proto.inst Classes SecureExec.exception.Exception Namespace: inst SecureExec.tools.proto. inst Source: tools.js, line 18 Methods &lt;static&gt; isError(e) This function checks whether @e is an instance of Error, i.e. whether @e is a normal Javascript error. Parameters: Name Type Description e object Object to check whether this is a Javascript error. Source: tools.js, line 77 Returns: Type boolean &lt;static&gt; isException(e) Checks whether an object is an instance of the SecureExec custom exception type SecureExec.exception.Exception. Please note this function will not return true on plain Javascript errors / exceptions but is for checking for an instance of SecureExec.exception.Exception. Parameters: Name Type Description e object Object to check whether is a SecureExec.exception.Exception. Source: tools.js, line 60 Returns: Type boolean &lt;static&gt; isInstanceOf(obj, inst) This function is a convenience wrapper for instanceof. It checks whether an object is an instance of a class, but doesn't throw exceptions if for example the instance argument is undefined. This function will return true if @obj is an instance of @inst, and false if not so, or if an error occurs. Parameters: Name Type Description obj object Object to check if it is an instance of @inst. inst function Class to check whether @inst is an instance of. Source: tools.js, line 25 Returns: Type boolean × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
